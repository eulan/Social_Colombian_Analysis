# -*- coding: utf-8 -*-
"""caracterizacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gJyoXbFQlvKQ71asQizOC2mD-2NU14lo
"""

from google.colab import drive
drive.mount('/content/gdrive')

path = '/content/gdrive/My Drive/Colab Notebooks/folium/Caracterizaci_n_del_Empleo_P_blico.csv'
import pandas as pd 
df = pd.read_csv(path)
df = df.dropna()
df =df.loc[df["GENERO: HOMBRE"] <= 400]
df = df.loc[df["GENERO: MUJER"] <= 400]
df.columns = map(str.lower, df.columns)



df.describe()

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import colors
from matplotlib.ticker import PercentFormatter

num_bins = 200

#plt.scatter(df.loc[df["GENERO: HOMBRE"] != 0]["GENERO: HOMBRE"], df.loc[df["GENERO: HOMBRE"] != 0]["NIVEL EDUCATIVO: DOCTORADO"])     
#plt.hist(df.loc[df["GENERO: HOMBRE"] != 0]["REGIÓN PND"], num_bins)
#plt.xlim(0,300)
#plt.ylim(0,100)

df.loc[df["genero: hombre"] != 0].head()

fig = plt.figure(figsize = (10,10))


plt.subplot(411)
objects = ("Hombres", "Mujeres")
y_pos = np.arange(len(objects))
performance = [df["genero: hombre"].sum(),df["genero: mujer"].sum()]
plt.barh(y_pos, performance, align='center', alpha=0.5)
plt.yticks(y_pos, objects)
plt.xlabel('Población')
plt.title('Genero')

plt.subplot(412)
objects = tuple(df.iloc[:,22:30].columns)
y_pos = np.arange(len(objects))
performance = []
for label in objects:
  performance.append(df.iloc[:,22:30][label].sum())
performance
plt.barh(y_pos, performance, align='center', alpha=0.5)
plt.yticks(y_pos, objects)
plt.xlabel('Población')
plt.title('Nivel Educativo')

plt.subplot(413)
objects = tuple(df.iloc[:,30:35].columns)
y_pos = np.arange(len(objects))
performance = []
for label in objects:
  performance.append(df.iloc[:,30:35][label].sum())
performance
plt.barh(y_pos, performance, align='center', alpha=0.5)
plt.yticks(y_pos, objects)
plt.xlabel('Población')
plt.title('Rangos de edades')

plt.subplot(414)
objects = tuple(df.iloc[:,36:42].columns)
y_pos = np.arange(len(objects))
performance = []
for label in objects:
  performance.append(df.iloc[:,36:42][label].sum())
performance
plt.barh(y_pos, performance, align='center', alpha=0.5)
plt.yticks(y_pos, objects)
plt.xlabel('Población')
plt.title('Experencial laboral')




fig.subplots_adjust(left = 0.0, right = 0.9, bottom = 0.1, top = 0.9 ,hspace=0.8)
fig.savefig("/content/gdrive/My Drive/Colab Notebooks/folium/variables_salarios_1.png")
plt.show()

import numpy as np
from wordcloud import WordCloud, ImageColorGenerator
from os import path
from PIL import Image
import os

fig = plt.figure(figsize = (10,10))

plt.subplot(221)
plt.title("Nombre de la entidad")
text = " "
text = text.join(list(df["nombre de la entidad"]))
col = np.array(Image.open(path.join('/content/gdrive/My Drive/Colab Notebooks/folium/', "266017_1.jpg")))
wordcloud = WordCloud(width=1200, height=1200, max_words=8299, stopwords=["De","LA", "EL", "DEL", "SAN"], mask=col,max_font_size=100, random_state=42).generate(text)
image_colors = ImageColorGenerator(col)
plt.imshow(wordcloud.recolor(color_func=image_colors), interpolation='bilinear')

plt.subplot(222)
plt.title("Naturaleza Jurídica")
text = " "
text = text.join(list(df["naturaleza jurídica"]))
col = np.array(Image.open(path.join('/content/gdrive/My Drive/Colab Notebooks/folium/', "266017_1.jpg")))
wordcloud = WordCloud(width=1200, height=1200, max_words=8299, stopwords=["De","LA", "EL", "DEL", "SAN"], mask=col, max_font_size=100, random_state=42).generate(text)
image_colors = ImageColorGenerator(col)
plt.imshow(wordcloud.recolor(color_func=image_colors), interpolation='bilinear')

plt.subplot(223)
plt.title("Departamentos")
text = " "
text = text.join(list(df["departamento"]))
col = np.array(Image.open(path.join('/content/gdrive/My Drive/Colab Notebooks/folium/', "266017_1.jpg")))
wordcloud = WordCloud(width=1200, height=1200, max_words=8299, stopwords=["De","LA", "EL", "DEL", "SAN"], mask=col, max_font_size=100, random_state=42).generate(text)
image_colors = ImageColorGenerator(col)
plt.imshow(wordcloud.recolor(color_func=image_colors), interpolation='bilinear')

plt.subplot(224)
plt.title("Municipios")
text = " "
text = text.join(list(df["municipio"]))
col = np.array(Image.open(path.join('/content/gdrive/My Drive/Colab Notebooks/folium/', "266017_1.jpg")))
wordcloud = WordCloud(width=1200, height=1200, max_words=8299, stopwords=["De","LA", "EL", "DEL", "SAN"], mask=col, max_font_size=100, random_state=42).generate(text)
image_colors = ImageColorGenerator(col)
plt.imshow(wordcloud.recolor(color_func=image_colors), interpolation='bilinear')


fig.subplots_adjust(hspace=-0.5)
fig.savefig("/content/gdrive/My Drive/Colab Notebooks/folium/woldcloud_salarios.png")
plt.show()

!pip install -q matplotlib-venn
!sudo apt-get install libgeos-3.5.0
!sudo apt-get install libgeos-dev
!sudo pip install https://github.com/matplotlib/basemap/archive/master.zip

import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from mpl_toolkits.basemap import Basemap
from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable
from mpl_toolkits.axes_grid1.colorbar import colorbar
from numpy import meshgrid
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

X = df.loc[df['genero: mujer'] != 0].iloc[:,20:45].to_numpy()
X1 = df.loc[df['genero: hombre'] != 0].iloc[:,20:45].to_numpy()
sil = []
kmax = 10

# dissimilarity would not be defined for a single cluster, thus, minimum number of clusters should be 2
for k in range(2, kmax+1):
  kmeans = KMeans(n_clusters = k).fit(X)
  labels = kmeans.labels_
  sil.append(silhouette_score(X, labels, metric = 'euclidean'))

def calculate_WSS(points, kmax):
  sse = []
  for k in range(1, kmax+1):
    kmeans = KMeans(n_clusters = k).fit(points)
    centroids = kmeans.cluster_centers_
    pred_clusters = kmeans.predict(points)
    curr_sse = 0
    
    # calculate square of Euclidean distance of each point from its cluster center and add to current WSS
    for i in range(len(points)):
      curr_center = centroids[pred_clusters[i]]
      curr_sse += (points[i, 0] - curr_center[0]) ** 2 + (points[i, 1] - curr_center[1]) ** 2
      
    sse.append(curr_sse)
  return sse

plt.plot(calculate_WSS(X1, kmax))
plt.plot(sil)

kmeans = KMeans(n_clusters = 4).fit(X)
labels = kmeans.labels_

for i in range(0, len(labels)):
  if (labels[i] == 0):
    plt.scatter(X[i,0],X[i,22], color = 'r')
  if (labels[i] == 1):
    plt.scatter(X[i,0],X[i,22], color = 'b')
  if (labels[i] == 2):
    plt.scatter(X[i,0],X[i,22], color = 'g')
  if (labels[i] == 3):
    plt.scatter(X[i,0],X[i,22], color = 'y')
plt.xlim(0,400)

kmeans = KMeans(n_clusters = 3).fit(X1)
labels = kmeans.labels_

for i in range(0, len(labels)):
  if (labels[i] == 0):
    plt.scatter(X1[i,0],X1[i,22], color = 'r')
  if (labels[i] == 1):
    plt.scatter(X1[i,0],X1[i,22], color = 'b')
  if (labels[i] == 2):
    plt.scatter(X1[i,0],X1[i,22], color = 'g')
#plt.scatter(X1[:,0],X1[:,22], color = 'b')
plt.xlim(0,400)

fig = plt.figure(figsize = (20,20))

ax = plt.subplot(2,2,(2,4))
lat = df['latitud'].values
lon = df['longitud'].values
maximos = df["salario mensual promedio"]/1000000
areas = df["salario mensual promedio"]/10000

# Establecemos la proyección del mapa base
m = Basemap(
    ax = ax,
    resolution = 'i',
    projection = 'merc',
    llcrnrlon = -79, llcrnrlat = -5,
    urcrnrlon = -65.537390, urcrnrlat = 11.934540 
)
 
# Establecemos las capas vectoriales a cargar como mapa base
m.drawcoastlines(color='gray')
m.drawcountries(color='black')
m.drawstates(color='gray')
m.etopo(scale=0.2, alpha=0.3)
plotter = m.scatter(lon, lat, latlon=True,
          c=maximos, s=areas,
          cmap='viridis', alpha=2)
cb = fig.colorbar(plotter, ax=ax)

plt.subplot(2,2,1)

kmeans = KMeans(n_clusters = 4).fit(X)
labels = kmeans.labels_

for i in range(0, len(labels)):
  if (labels[i] == 0):
    plt.scatter(X[i,0],X[i,22], color = 'r')
  if (labels[i] == 1):
    plt.scatter(X[i,0],X[i,22], color = 'b')
  if (labels[i] == 2):
    plt.scatter(X[i,0],X[i,22], color = 'g')
  if (labels[i] == 3):
    plt.scatter(X[i,0],X[i,22], color = 'y')
plt.xlim(0,400)
plt.xlabel("genero : hombre")
plt.ylabel("Salario promedio/1e7")
plt.title("Si, genero : mujer != 0")
plt.subplot(2,2,3)
kmeans = KMeans(n_clusters = 3).fit(X1)
labels = kmeans.labels_

for i in range(0, len(labels)):
  if (labels[i] == 0):
    plt.scatter(X1[i,0],X1[i,22], color = 'r')
  if (labels[i] == 1):
    plt.scatter(X1[i,0],X1[i,22], color = 'b')
  if (labels[i] == 2):
    plt.scatter(X1[i,0],X1[i,22], color = 'g')
#plt.scatter(X1[:,0],X1[:,22], color = 'b')
plt.xlim(0,400)
plt.xlabel("genero : hombre")
plt.ylabel("Salario promedio/1e7")
plt.title("Si, genero : hombre != 0")
fig.savefig("/content/gdrive/My Drive/Colab Notebooks/folium/variables_salarios.png")
plt.show()

import seaborn as sns
from scipy.stats import pearsonr

def corrfunc(x,y, ax=None, **kws):
    """Plot the correlation coefficient in the top left hand corner of a plot."""
    r, _ = pearsonr(x, y)
    ax = ax or plt.gca()
    # Unicode for lowercase rho (ρ)
    rho = '\u03C1'
    ax.annotate(f'{rho} = {r:.2f}', xy=(.1, .9), xycoords=ax.transAxes)

dg = df.loc[df['GENERO: HOMBRE'] != 0].iloc[:,20:45]
dg.columns = map(str.lower, dg.columns)
fig = sns.pairplot(dg).map_lower(corrfunc)
fig.savefig("/content/gdrive/My Drive/Colab Notebooks/folium/correlation_terms_salarios_public.png")
plt.show()

X=dg.iloc[:,0:22]
y = dg.iloc[:,22].values
from sklearn.preprocessing import  MinMaxScaler
sc= MinMaxScaler()
X= sc.fit_transform(X)
y= y.reshape(-1,1)
y=sc.fit_transform(y)
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

from keras import Sequential
from keras.layers import Dense
def build_regressor():
    regressor = Sequential()
    regressor.add(Dense(units=40, input_dim=22))
    regressor.add(Dense(units=22, input_dim=40))
    regressor.add(Dense(units=1))
    regressor.compile(optimizer='adam', loss='mean_squared_error',  metrics=['mae','accuracy'])
    return regressor
from keras.wrappers.scikit_learn import KerasRegressor
regressor = KerasRegressor(build_fn=build_regressor, batch_size=32,epochs=100)

results=regressor.fit(X_train,y_train)

y_pred= regressor.predict(X_test)
fig, ax = plt.subplots()
ax.scatter(X_test[:,0], y_test)
ax.scatter(X_test[:,0], y_pred, color = 'r')
#ax.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=4)
ax.set_xlabel('Measured')
ax.set_ylabel('Predicted')
plt.show()

